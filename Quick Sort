#include <iostream>
#include <chrono>
#include <cstdlib>  // cho rand() và srand()
#include <ctime>    // cho time()
using namespace std;
// Cấu trúc của một nút trong danh sách liên kết
struct Node {
    int data;
    Node* next;

    Node(int val) : data(val), next(nullptr) {}
};

// Hàm để in danh sách liên kết
void printList(Node* head) {
    while (head != nullptr) {
        cout << head->data << " -> ";
        head = head->next;
    }
    cout << "NULL" << endl;
}

// Hàm thêm một nút vào cuối danh sách
void push(Node** head_ref, int new_data) {
    Node* new_node = new Node(new_data);
    if (*head_ref == nullptr) {
        *head_ref = new_node;
        return;
    }
    Node* last = *head_ref;
    while (last->next != nullptr) {
        last = last->next;
    }
    last->next = new_node;
}

// Hàm lấy nút cuối cùng của danh sách.
Node* getTail(Node* current) {
    while (current != nullptr && current->next != nullptr) {
        current = current->next;
    }
    return current;
}

// Hàm phân vùng danh sách.
Node* partition(Node* head, Node* tail, Node** newHead, Node** newTail) {
    Node* pivot = tail;
    Node* prev = nullptr;
    Node* current = head;
    Node* end = pivot;

    *newHead = nullptr;
    *newTail = nullptr;

    while (current != pivot) {
        if (current->data < pivot->data) {
            if (*newHead == nullptr) {
                *newHead = current;
            }
            prev = current;
            current = current->next;
        } else {
            if (prev) {
                prev->next = current->next;
            }
            Node* temp = current->next;
            current->next = nullptr;
            end->next = current;
            end = current;
            current = temp;
        }
    }

    if (*newHead == nullptr) {
        *newHead = pivot;
    }

    *newTail = end;

    return pivot;
}

// Hàm chính thực hiện Quick Sort
Node* quickSortRecur(Node* head, Node* tail) {
    if (!head || head == tail) {
        return head;
    }

    Node* newHead = nullptr;
    Node* newTail = nullptr;

    Node* pivot = partition(head, tail, &newHead, &newTail);

    if (newHead != pivot) {
        Node* temp = newHead;
        while (temp->next != pivot) {
            temp = temp->next;
        }
        temp->next = nullptr;

        newHead = quickSortRecur(newHead, temp);

        temp = getTail(newHead);
        temp->next = pivot;
    }

    pivot->next = quickSortRecur(pivot->next, newTail);

    return newHead;
}

// Hàm bao bọc để gọi Quick Sort
void quickSort(Node** headRef) {
    *headRef = quickSortRecur(*headRef, getTail(*headRef));
}

int main() {
    Node* head = nullptr;

    // Khởi tạo seed cho số ngẫu nhiên
    srand(time(0));  // seed theo thời gian hiện tại

    const int N = 1000;  // số lượng phần tử ngẫu nhiên

    // Tạo 1000 số ngẫu nhiên và thêm vào danh sách liên kết
    for (int i = 0; i < N; ++i) {
        int randomNumber = rand() % 10000;  // số từ 0 đến 9999
        push(&head, randomNumber);
    }

    cout << "Dang sap xep danh sach lien ket co " << N << " phan tu..." << endl;

    // Đo thời gian với ctime
    clock_t start = clock();

    quickSort(&head);

    clock_t end = clock();

    double time_taken = double(end - start) / CLOCKS_PER_SEC;

   cout << "Sap xep hoan tat." << endl;
   cout << "Thoi gian chay: " << time_taken << " giay" << endl;
    Node* temp = head;

    int count = 0;
    while (temp != nullptr && count < 20) {
    cout << temp->data << " -> ";
    temp = temp->next;
    ++count;
}
cout << "..." << endl;
    return 0;
    
}
